# 5. 实战场景：沉淀团队研发资产

> 新人入职，第一周都在看 Wiki 里的“前端代码规范”，看完第二天写代码依然犯错。
> **现在，把 Wiki 直接变成 AI 的“思想钢印”。**

## 场景 1：把前端代码规范转化为 `.cursorrules`

**痛点**: 团队规定了严格的 React Hooks 使用规范和文件命名，代码审查 (CR) 经常因为格式打回。
**解法**: 在项目根目录（或通过 Cursor Directory）下发 `.cursorrules`。

```markdown
# Front-end Project `.cursorrules`

## 1. 核心技术栈
- React 18 (严格遵循 Functional Component 范式)
- TypeScript (禁止使用 `any`，必须定义 Interface)

## 2. 状态管理规范 (强制)
当用户要求新建一个跨组件共享状态时：
- ❌ 绝对不要引入 Redux 或 Context API。
- ✅ 必须使用 Zustand，并且状态定义必须放在 `src/store/` 目录下。

## 3. 命名约定
- 所有组件文件必须使用 PascalCase (例如 `UserCard.tsx`)。
- 所有工具函数必须使用 camelCase (例如 `formatDate.ts`)。
```

<div class="mt-4 p-4 bg-green-50 text-green-800 rounded-lg text-sm border border-green-200">
<strong>降维打击</strong>: 以后只要研发按下 `Cmd+K` 让 AI 写代码，AI 自动受此规则约束。这比任何 ESLint 插件都更具语义理解能力，因为 AI 可以审查业务逻辑命名！
</div>

---

## 场景 2：结合 MCP 编排“发版验收”工作流 (Skill)

**痛点**: 每次发版前都要手动跑单测、查包大小、最后还要切去终端打 Git Tag。
**解法**: 编写一个复合能力的 Claude Skill，它能调度多个工具来完成整个 SOP。

```yaml
# ~/.claude/skills/release-check.md
---
name: release-check
description: 执行上线前的最终全量检查，包含测试、构建和打 tag。
allowed-tools: [bash, git, mcp_jira] # 声明：该技能允许 AI 使用终端、Git 和 Jira 插件
---

当用户输入 `/release` 时，请严格按照以下顺序执行：
1. 运行 `npm run test:coverage`。如果覆盖率低于 80%，立即报错并停止。
2. 运行 `npm run build`，检查 `dist` 目录大小是否超过 5MB，若超过需给用户发警告。
3. 调用 `mcp_jira` 工具，读取当前绑定的 Jira Issue 状态。若未处于 "Done" 或 "QA Passed"，拒绝发版。
4. 一切通过后，使用 bash 运行 `git tag v{版本号}`。
```

<div class="mt-4 p-4 bg-purple-50 text-purple-800 rounded-lg text-sm border border-purple-200">
<strong>价值升维</strong>: 我们不再是教 AI “写代码”，而是在教 AI “当研发主管”。把极度容易遗漏的发版 SOP 固化为一键执行的 Agent 工作流。
</div>
