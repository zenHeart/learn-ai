# 实战案例

## 案例 1：代码审查与质量门禁 Agent

**场景**: 在 CI/CD 流程中自动进行深度代码审查

**架构**:
- **Scanner**: 调用 Linter 和 Static Analysis 工具
- **Analyzer**: 利用 LLM 对比项目规约 (`AGENTS.md`) 识别设计偏差
- **Reporter**: 自动在 PR 中留言并给出修复建议

---

## 案例 2：遗留代码迁移与现代化 Agent

**场景**: 将整个模块从旧框架（如 Vue2/React Class）迁移到现代架构

**流程**:
1. **Inventory**: 扫描目录下所有相关文件
2. **Analysis**: 构建组件依赖图，识别核心逻辑
3. **Execution**: 逐个转换文件，并自动补充 TypeScript 类型
4. **Validation**: 自动编写并运行单元测试

---

## 案例 3：安全漏洞自动化补丁 Agent

**场景**: 发现 CVE 漏洞后自动修复并验证

**能力**:
- **Detection**: 通过 MCP 连接安全扫描工具获取漏洞详情
- **Patching**: 寻找兼容的依赖版本并修改代码中的危险用法
- **Verification**: 运行回归测试确保修复不影响原有功能

---

## 案例 4：文档与注释同步 Agent

**场景**: 当代码逻辑变更时，自动更新相关的 README 和 API 文档

**流程**:
1. 监听 Git 提交
2. 分析代码变更的语义
3. 更新 Markdown 文档
4. 提交文档更新 PR

---

# 调试与监控

- **执行轨迹 (Trace)**: 记录 Agent 思考的每一步
- **Token 消耗监控**: 防止无限循环导致的高昂账单
- **干预点设置**: 允许人类在关键决策步进行 "Pause & Resume"
- **异常捕获**: 工具调用失败后的重试策略

---

# 故障排除

## 常见问题 1：Agent 进入无限循环

**解决方案**:
- 设置 `max_iterations` 硬限制
- 检测重复的输出模式 (Repeated Thought Detection)

## 常见问题 2：上下文污染/丢失

**解决方案**:
- 采用 `/compact` 或长效记忆机制
- 优先提供精简的 `Interface/Type` 而非全量代码

---

# Agent 动手练习

## 练习 1：构建 CLI 自动化 Agent
**任务**: 创建一个能自动读取错误日志并搜索 StackOverflow 给出建议的 Agent

---

## 练习 2：实现带反思的重构 Loop
**任务**: 实现一个 Agent，在修改代码后自动运行测试，若失败则根据报错自动重试，直到通过

---

## 练习 3：多 Agent 协作流
**任务**: 模拟 Planner + Coder + Reviewer 的协作模式完成一个小功能
