# 5. 实战场景：代码驱动的轻量级 Agent

> 抛弃黑盒框架，使用前端最熟悉的 [Vercel AI SDK](https://sdk.vercel.ai/docs) 编写一个透明、可控的“代码审查流水线”。

## 场景：构建“Coder + Reviewer”协作流

**痛点**: 使用重型框架（如 AutoGen）调试困难，状态难以追踪。
**解法**: 用代码显示定义工作流（Code as Agent），逻辑透明，高度可控。

```typescript
import { generateText } from 'ai';
import { openai } from '@ai-sdk/openai';

// 1. Worker: Coder Agent (负责生成代码)
async function coderAgent(requirement: string) {
  const { text } = await generateText({
    model: openai('gpt-4o-mini'), // 执行者用小模型即可
    system: '你是一个资深前端开发。请只输出纯代码，不要任何废话。',
    prompt: requirement,
  });
  return text;
}

// 2. Verifier: Reviewer Agent (负责审查)
async function reviewerAgent(code: string) {
  const { text } = await generateText({
    model: openai('gpt-4o'), // 审查者必须用推理能力强的大模型
    system: '你是一个严格的代码审查专家。请检查代码是否有明显漏洞。如果有，请输出"REJECT: 理由"；如果没有，输出"PASS"。',
    prompt: code,
  });
  return text;
}
```

---

# Orchestrator：用代码编排状态机

```typescript
// 3. Orchestrator: 总控调度器 (状态机)
async function runDevPipeline(requirement: string, maxRetries = 3) {
  let attempt = 0;
  let currentRequirement = requirement;

  while (attempt < maxRetries) {
    console.log(`\n--- 第 ${attempt + 1} 次尝试 ---`);
    
    // Step A: Coder 写代码
    console.log("Coder 正在编写代码...");
    const draftCode = await coderAgent(currentRequirement);
    
    // Step B: Reviewer 审查代码
    console.log("Reviewer 正在审查代码...");
    const reviewResult = await reviewerAgent(draftCode);
    
    // Step C: 判断流转状态
    if (reviewResult.includes("PASS")) {
      console.log("✅ 审查通过！流水线完成。");
      return draftCode;
    } else {
      console.log(`❌ 审查被拒，打回重做: ${reviewResult}`);
      // 将 Reviewer 的意见追加到需求中，让 Coder 下一轮修改
      currentRequirement = `需求：${requirement}\n前一版代码：${draftCode}\n审查意见：${reviewResult}。请修正。`;
      attempt++;
    }
  }
  
  throw new Error("达到最大重试次数，流水线失败。需要人工介入。");
}

// 触发执行
await runDevPipeline("写一个防抖函数 debounce");
```

<div class="mt-4 p-4 bg-green-50 text-green-800 rounded-lg text-sm border border-green-200">
<strong>核心优势</strong>: 整个逻辑就是一段原生的 `while` 循环和 `if-else`。你可以随时 <code>console.log</code>，随时打断点调试。没有任何魔法，这就是最稳定、最工业级的 Agent 实现方式。
</div>
