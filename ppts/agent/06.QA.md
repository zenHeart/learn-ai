---
layout: section
---

# 6. QA 问答环节

---
layout: default
---
### **Q1: Agent 听起来很高大上，但实际落地总是各种不可控，怎么解决工程化问题？**

A: **不要为了 Agent 而 Agent。收起“完全自主”的幻想，拥抱“状态机”。**

<div class="mt-6 space-y-5 text-sm">

- **权威背书**: [Anthropic 官方研究](https://www.anthropic.com/research/building-effective-agents)指出，大多数任务根本不需要复杂的自主 Agent（Autonomous Agent）。
- **工程解法**: 工业级的解法是 **Workflows (工作流)**。用硬编码的 `if/else`、`while` 循环或者状态机引擎 (如 xstate) 把流程框死。只有在特定的节点，才调用 LLM 进行非确定性推理。**约束越强，落地越稳**。

</div>

---
layout: two-cols
---

### **Q2: 为什么我的 Agent 经常陷入死循环（Looping）？**

A: **因为它“既当裁判，又当选手”。**

<div class="mt-6 space-y-4 text-sm">

1. **单体缺陷**: 如果同一个模型自己写代码，又自己看报错日志，它很容易陷入思维定势，不断尝试同一种错误的修复方法。
2. **正确解法 (Mono-PI 模式)**: 必须把 **执行者 (Worker)** 和 **验证者 (Verifier)** 拆分开。并且验证者最好是确定的程序（比如 `npm run test`）或者是一个拥有不同 System Prompt 的独立 LLM。一旦发现重复报错，立刻通过 Orchestrator (总控) 阻断循环，请求人类介入。

</div>

::right::

### **Q3: 有这么多框架（LangChain, AutoGen, CrewAI...），我到底该学哪个？**

A: **对于有代码能力的研发，建议抛弃重型框架，直接用 SDK (Code-as-Agent)。**

<div class="mt-6 space-y-4 text-sm">

1. **重型框架的代价**: 它们抽象层太厚，当你遇到 Agent 迷失方向时，你很难调试底层 Prompt 和中间状态。
2. **推荐方案**: 
   - 前端/Node.js 推荐 **Vercel AI SDK**。
   - Python 推荐直接调 OpenAI/Anthropic 官方 SDK，或使用极简的 **smolagents**。把控制流 (Control Flow) 还给代码，把生成流交给 LLM。

</div>

---
layout: center
---

# 🎉 Thank You

<div class="text-center mt-12">

<h2 class="text-2xl font-bold mb-8">Agent: 从“黑盒玩具”到“工业流水线”</h2>

<div class="inline-block p-8 bg-slate-50 dark:bg-slate-800/50 border border-slate-200 dark:border-slate-700/50 rounded-2xl shadow-sm">
  <div class="text-xl flex items-center justify-center gap-4 font-semibold text-slate-700 dark:text-slate-200">
    <span class="px-4 py-2 bg-white dark:bg-slate-700 rounded-lg shadow-sm">代码编排的 Workflow</span>
    <span class="text-blue-500 font-bold">+</span> 
    <span class="px-4 py-2 bg-white dark:bg-slate-700 rounded-lg shadow-sm">多智能体交叉验证</span>
  </div>
</div>

<div class="mt-16 text-2xl font-bold text-slate-700 dark:text-slate-300">
  Questions? 🙋‍♂️
</div>

</div>
