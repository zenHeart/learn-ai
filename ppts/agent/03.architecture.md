# 3. 架构演进：从单体到多智能体协同

> 为什么复杂的编码任务不能只丢给一个大模型完成？

## 强对比：单体大模型 vs 多智能体交叉验证

<div class="grid grid-cols-2 gap-8 mt-6">

<div class="p-4 border border-red-200 rounded-lg bg-red-50/30">

### ❌ 传统单体 Agent (ReAct)
* **架构**: 一个模型既当产品经理，又当程序员，又当测试。
* **痛点**: 
  - 上下文极易污染，写代码时忘记了需求。
  - “当局者迷”，发现不了自己写的逻辑漏洞。
  - 极易陷入 "执行报错 -> 乱改 -> 再次报错" 的无限死循环。

</div>

<div class="p-4 border border-green-200 rounded-lg bg-green-50/30">

### ✅ 现代多智能体协同 (Multi-Agent)
* **架构**: [Orchestrator-Workers](https://www.anthropic.com/research/building-effective-agents) / [Magentic-One](https://www.microsoft.com/en-us/research/project/magentic-one/)。
* **优势**:
  - **职能隔离**: Planner 拆解任务，Coder 专注写代码，Reviewer 专挑刺。
  - **交叉验证**: 强迫不同的模型实体互相审核（如 Mono-PI 论文提出的“单体规划者-多重验证者”模式）。

</div>

</div>

---

# 工业级 Orchestrator-Workers 架构图

```mermaid
flowchart TD
    User([用户需求: 开发登录模块]) --> Orchestrator
    
    subgraph "Orchestrator (总控/规划者) - 拥有全局上下文"
        Orchestrator[[Task Planner Agent]]
        Orchestrator -.分配.-> Task1(Task 1: 前端 UI)
        Orchestrator -.分配.-> Task2(Task 2: 后端 API)
        Orchestrator -.分配.-> Task3(Task 3: 数据库迁移)
    end
    
    subgraph "Workers (执行者) - 只有局部上下文"
        Coder1[[Frontend Coder Agent]]
        Coder2[[Backend Coder Agent]]
        DBA[[DBA Agent]]
    end
    
    subgraph "Verifiers (验证者) - 独立审查"
        Reviewer[[Code Reviewer Agent]]
        Tester[[QA Agent (跑单测)]]
    end

    Task1 --> Coder1
    Task2 --> Coder2
    Task3 --> DBA
    
    Coder1 & Coder2 & DBA --> Reviewer
    Reviewer -- "打回重做" --> Coder1 & Coder2 & DBA
    Reviewer -- "通过" --> Tester
    Tester -- "报错" --> Coder1 & Coder2 & DBA
    Tester -- "绿灯" --> Orchestrator
```

---

# 核心组件与职能

<div class="grid grid-cols-2 gap-6 mt-4">

<div class="bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl border border-slate-200">

### 1. Orchestrator（总控大脑）
- **职责**: 负责接收任务，将大目标拆解为 DAG（有向无环图）子任务。
- **能力**: 它不写代码，它只负责“分配工作”和“汇总成果”。
- **选型**: 必须使用推理能力最强的模型（如 Claude 3.5 Sonnet）。

</div>

<div class="bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl border border-slate-200">

### 2. Workers（执行工蜂）
- **职责**: 接收到非常具体的子任务和极其纯净的上下文，调用工具（Tool Use）干活。
- **选型**: 可以使用廉价、快速的小模型（如 Haiku / GPT-4o-mini）。

</div>

<div class="bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl border border-slate-200">

### 3. Verifier（交叉验证器）
- **职责**: 这是破除死循环的关键。专门负责审查 Worker 产出的质量，运行 `npm run test`。不符合标准直接打回。
- **理论支撑**: [Mono-PI](https://arxiv.org/abs/2402.11450) 指出，多重维度的独立验证者能成倍提高最终代码的正确率。

</div>

<div class="bg-slate-50 dark:bg-slate-800/50 p-4 rounded-xl border border-slate-200">

### 4. Shared Memory（共享黑板）
- **职责**: Agent 之间不直接用自然语言聊天，而是通过一个共享的 JSON 状态（State）来传递进度。

</div>

</div>

---
layout: center
---
# 本章小结：架构设计

<v-clicks>

1. **核心痛点**: 单体 Agent 处理长链路编码任务极易崩溃。
2. **解题思路**: 引入软件工程的“康威定律”，按职能拆分 Agent（Orchestrator-Workers）。
3. **闭环关键**: 必须有独立于 Coder 之外的 **Verifier (测试/审查者)** 来进行强制交叉验证。

</v-clicks>
