import{_ as e}from"./chunks/plugin-vue_export-helper.DlAUqK2U.js";import{c as o,o as r,ad as a}from"./chunks/mermaid.Cb40Nz1P.js";import"./chunks/cytoscape.C2CwDKBM.js";import"./chunks/dayjs.C32PoDnw.js";const p=JSON.parse('{"title":"面向前段开发者的 AI 工程模式","description":"","frontmatter":{},"headers":[],"relativePath":"zh/tech/patterns/index.md","filePath":"zh/tech/patterns/index.md"}'),l={name:"zh/tech/patterns/index.md"};function n(i,t,s,g,d,h){return r(),o("div",null,[...t[0]||(t[0]=[a('<h1 id="面向前段开发者的-ai-工程模式" tabindex="-1">面向前段开发者的 AI 工程模式 <a class="header-anchor" href="#面向前段开发者的-ai-工程模式" aria-label="Permalink to &quot;面向前段开发者的 AI 工程模式&quot;">​</a></h1><p>作为前端工程师，我们习惯了 <em>Container/Presenter</em>、<em>Hooks</em> 或 <em>MVC</em> 等设计模式。AI 工程也有自己的一套模式，作为智能应用程序的构建模块。</p><h2 id="_4-个核心模式" tabindex="-1">4 个核心模式 <a class="header-anchor" href="#_4-个核心模式" aria-label="Permalink to &quot;4 个核心模式&quot;">​</a></h2><h3 id="_1-提示词链-顺序处理" tabindex="-1">1. 提示词链 (顺序处理) <a class="header-anchor" href="#_1-提示词链-顺序处理" aria-label="Permalink to &quot;1. 提示词链 (顺序处理)&quot;">​</a></h3><p><strong>类比:</strong> 就像 JavaScript 中的 Promise 链 (<code>.then().then()</code>)。 <strong>是什么:</strong> 将复杂的任务分解为一系列更小、更简单的提示词。 <strong>何时使用:</strong></p><ul><li>复杂的转换 (例如 &quot;提取数据&quot; -&gt; &quot;格式化为 JSON&quot; -&gt; &quot;翻译&quot;)。</li><li>通过逐步验证确保可靠性。</li><li><strong>示例:</strong> 一个 &quot;代码审查器&quot;，首先总结更改，然后检查错误，最后建议改进。</li></ul><h3 id="_2-rag-检索增强生成" tabindex="-1">2. RAG (检索增强生成) <a class="header-anchor" href="#_2-rag-检索增强生成" aria-label="Permalink to &quot;2. RAG (检索增强生成)&quot;">​</a></h3><p><strong>类比:</strong> 用户在回答问题之前搜索数据库。 <strong>是什么:</strong> 检索相关数据（来自文档、数据库、API）并将其注入到 LLM 的上下文窗口中，然后再要求其生成答案。 <strong>何时使用:</strong></p><ul><li>回答有关私有/专有数据的问题。</li><li>绕过 LLM 的知识截止日期。</li><li>通过将模型建立在事实基础上来减少幻觉。</li><li><strong>示例:</strong> 客户支持机器人，内部知识库搜索。</li></ul><h3 id="_3-结构化输出-类型安全-ai" tabindex="-1">3. 结构化输出 (类型安全 AI) <a class="header-anchor" href="#_3-结构化输出-类型安全-ai" aria-label="Permalink to &quot;3. 结构化输出 (类型安全 AI)&quot;">​</a></h3><p><strong>类比:</strong> API 响应的 TypeScript 接口。 <strong>是什么:</strong> 强制 LLM 返回符合模式 (例如 Zod) 的严格格式化数据 (通常是 JSON)。 <strong>何时使用:</strong></p><ul><li>将 AI 与现有软件集成 (函数参数, UI props)。</li><li>数据提取 (例如，解析简历、收据)。</li><li><strong>示例:</strong> 一个 &quot;收据扫描仪&quot;，输出 <code>{ total: number, date: string, items: [] }</code> 而不是自由文本。</li></ul><h3 id="_4-智能体与工具-自主执行" tabindex="-1">4. 智能体与工具 (自主执行) <a class="header-anchor" href="#_4-智能体与工具-自主执行" aria-label="Permalink to &quot;4. 智能体与工具 (自主执行)&quot;">​</a></h3><p><strong>类比:</strong> 可以调用 API 函数的后台工作者或状态机。 <strong>是什么:</strong> 赋予 LLM 访问 &quot;工具&quot; (函数) 的权限，并允许它决定<em>哪个</em>工具被调用以及<em>何时</em>调用以解决问题。 <strong>何时使用:</strong></p><ul><li>需要外部操作的多步任务 (例如 &quot;预订航班&quot;)。</li><li>路径非线性的工作流。</li><li><strong>示例:</strong> 一个 &quot;个人助理&quot;，可以检查你的日历、发送邮件并查询天气 API。</li></ul><h2 id="可靠-ai-设计原则" tabindex="-1">&quot;可靠 AI&quot; 设计原则 <a class="header-anchor" href="#可靠-ai-设计原则" aria-label="Permalink to &quot;&quot;可靠 AI&quot; 设计原则&quot;">​</a></h2><p>构建生产级 AI 是关于管理不确定性。</p><ol><li><strong>类型安全优先:</strong> 永远不要信任原始文本。始终根据模式 (Zod) 验证 AI 输出。</li><li><strong>优雅失败:</strong> AI <em>会</em>失败。实施重试逻辑和回退 UI (例如 &quot;我无法生成那个，重试一下？&quot;)。</li><li><strong>评估与迭代:</strong> 你无法修复你无法衡量的东西。使用 &quot;Evals&quot; (AI 的单元测试) 来跟踪质量。</li><li><strong>人机回环:</strong> 对于关键操作，在执行前始终询问用户确认。</li></ol><h2 id="前端-ai-技术栈" tabindex="-1">前端 AI 技术栈 <a class="header-anchor" href="#前端-ai-技术栈" aria-label="Permalink to &quot;前端 AI 技术栈&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:left;">层</th><th style="text-align:left;">技术</th><th style="text-align:left;">目的</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>UI / 框架</strong></td><td style="text-align:left;"><strong>Next.js / React</strong></td><td style="text-align:left;">用户交互的界面。</td></tr><tr><td style="text-align:left;"><strong>编排</strong></td><td style="text-align:left;"><strong>Vercel AI SDK</strong> / LangChain</td><td style="text-align:left;">管理 UI 和 LLM 之间的数据流。</td></tr><tr><td style="text-align:left;"><strong>模型 (大脑)</strong></td><td style="text-align:left;"><strong>OpenAI / Anthropic</strong></td><td style="text-align:left;">智能引擎。</td></tr><tr><td style="text-align:left;"><strong>上下文 (记忆)</strong></td><td style="text-align:left;"><strong>Pinecone / pgvector</strong></td><td style="text-align:left;">RAG 的长期记忆。</td></tr><tr><td style="text-align:left;"><strong>模式 (安全)</strong></td><td style="text-align:left;"><strong>Zod</strong></td><td style="text-align:left;">确保数据完整性。</td></tr></tbody></table><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><ul><li><strong>学习类型安全 AI:</strong> <a href="/learn-ai/tech/structured-output.html">结构化输出指南</a> (即将推出)</li><li><strong>构建 RAG 应用:</strong> <a href="/learn-ai/examples/rag-chatbot.html">RAG 教程</a></li><li><strong>探索智能体:</strong> <a href="/learn-ai/zh/integration/protocols/mcp.html">MCP 指南</a></li></ul>',22)])])}const f=e(l,[["render",n]]);export{p as __pageData,f as default};
