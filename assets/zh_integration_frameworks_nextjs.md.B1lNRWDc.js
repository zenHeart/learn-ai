import{_ as i}from"./chunks/plugin-vue_export-helper.DlAUqK2U.js";import{c as a,o as t,ad as n}from"./chunks/mermaid.Cb40Nz1P.js";import"./chunks/cytoscape.C2CwDKBM.js";import"./chunks/dayjs.C32PoDnw.js";const c=JSON.parse('{"title":"Next.js 集成模式","description":"","frontmatter":{},"headers":[],"relativePath":"zh/integration/frameworks/nextjs.md","filePath":"zh/integration/frameworks/nextjs.md"}'),e={name:"zh/integration/frameworks/nextjs.md"};function l(h,s,p,k,r,d){return t(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="next-js-集成模式" tabindex="-1">Next.js 集成模式 <a class="header-anchor" href="#next-js-集成模式" aria-label="Permalink to &quot;Next.js 集成模式&quot;">​</a></h1><p>Next.js 是构建 AI 应用程序的最流行框架，因为它对 <strong>流式传输</strong>、<strong>Edge 函数</strong> 和 <strong>Server Actions</strong> 有强大的支持。</p><h2 id="模式-1-路由处理程序-标准" tabindex="-1">模式 1: 路由处理程序 (标准) <a class="header-anchor" href="#模式-1-路由处理程序-标准" aria-label="Permalink to &quot;模式 1: 路由处理程序 (标准)&quot;">​</a></h2><p>最常见的模式是创建一个流式传输响应的 API 端点。</p><div class="language-typescript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">typescript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/api/chat/route.ts</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> runtime</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;edge&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用 Edge 获得更低延迟</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> POST</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">req</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Request</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 验证 auth ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 调用 LLM ...</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ... 返回流 ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>优点</strong>:</p><ul><li>适用于任何客户端（React, Vue, 移动应用）。</li><li>标准 REST API。</li></ul><h2 id="模式-2-server-actions" tabindex="-1">模式 2: Server Actions <a class="header-anchor" href="#模式-2-server-actions" aria-label="Permalink to &quot;模式 2: Server Actions&quot;">​</a></h2><p>直接从你的 UI 组件调用 AI，而无需手动 <code>fetch</code>。</p><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// app/actions.ts</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;use server&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { streamText } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;ai&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { openai } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@ai-sdk/openai&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { createStreamableValue } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;ai/rsc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> generateDescription</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">topic</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> stream</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createStreamableValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">textStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> streamText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      model: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">openai</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;gpt-4o&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      prompt: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Describe \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">topic</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> delta</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textStream) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(delta);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">done</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { output: stream.value };</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>优点</strong>:</p><ul><li>类型安全。</li><li>无需管理 API 路由。</li></ul><h2 id="模式-3-生成式-ui-rsc" tabindex="-1">模式 3: 生成式 UI (RSC) <a class="header-anchor" href="#模式-3-生成式-ui-rsc" aria-label="Permalink to &quot;模式 3: 生成式 UI (RSC)&quot;">​</a></h2><p>从服务器流式传输 React 组件。</p><p><em>详情请参阅 <a href="./vercel-ai-sdk.html">Vercel AI SDK 指南</a>。</em></p><h2 id="部署注意事项" tabindex="-1">部署注意事项 <a class="header-anchor" href="#部署注意事项" aria-label="Permalink to &quot;部署注意事项&quot;">​</a></h2><h3 id="_1-edge-vs-node-js-运行时" tabindex="-1">1. Edge vs. Node.js 运行时 <a class="header-anchor" href="#_1-edge-vs-node-js-运行时" aria-label="Permalink to &quot;1. Edge vs. Node.js 运行时&quot;">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">运行时</th><th style="text-align:left;">延迟</th><th style="text-align:left;">特性</th><th style="text-align:left;">超时</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Node.js</strong></td><td style="text-align:left;">中等</td><td style="text-align:left;">完整 Node API</td><td style="text-align:left;">高 (10s - 5min)</td></tr><tr><td style="text-align:left;"><strong>Edge</strong></td><td style="text-align:left;">低</td><td style="text-align:left;">有限 API</td><td style="text-align:left;">低 (30s)</td></tr></tbody></table><p><strong>建议</strong>: 聊天使用 <strong>Edge</strong> (快速 TTFT)。RAG 使用 <strong>Node.js</strong> (需要向量 DB 连接)。</p><h3 id="_2-超时" tabindex="-1">2. 超时 <a class="header-anchor" href="#_2-超时" aria-label="Permalink to &quot;2. 超时&quot;">​</a></h3><p>Vercel 有严格的超时限制。</p><ul><li><strong>Hobby</strong>: 10s (Serverless Function), 30s (Edge)。</li><li><strong>Pro</strong>: 300s (Serverless Function)。</li></ul><p><strong>修复</strong>: 始终使用流式传输。如果任务耗时 &gt;30s（如生成长报告），使用后台任务 (Inngest/Trigger.dev)。</p><h2 id="下一步" tabindex="-1">下一步 <a class="header-anchor" href="#下一步" aria-label="Permalink to &quot;下一步&quot;">​</a></h2><ul><li>使用 <strong><a href="./../../deployment/">部署指南</a></strong> 部署你的应用。</li></ul>`,25)])])}const F=i(e,[["render",l]]);export{c as __pageData,F as default};
